

    threadpool_t *p = pool_creation();

    hashtable_t *t = initTable( max_conn );

    checkin_arg *ar = ( checkin_arg *)malloc(sizeof( checkin_arg ) );
    ar->name = (char *)malloc( 20 * sizeof( char ) );
	ar->myt = t;

	for( int i = 0; i < 10; i++ )
	{
		printf( "inserisci\t" );
		gets( ar->name );
		threadpool_add( p, checkin, ar );
	}

	printf( "\n\n\n" );
	sleep( 2 );

	for( int i = 0; i < max_conn; i++ )
	{
		if( t->elem[i].nickname != NULL )
		{
			printf( "%s\n", t->elem[i].nickname );

			if( t->elem[i].collision != NULL )
			{
				node_t *n = t->elem[i].collision->head;
				while( n != NULL )
				{
					ht_elem_t *e = n->ptr;
					printf( "\t\t%s\n", e->nickname );
					n = n->next;
				}
			}
		}

	}

	for( int i = 0; i < 4; i++ )
	{
		printf( "\nrimuovi?\n" );
		gets( ar->name );


		printf( "%d\n",  delete( ar ) );


		for( int i = 0; i < max_conn; i++ )
		{
			if( t->elem[i].nickname != NULL )
			{
				printf( "%s\n", t->elem[i].nickname );

				if( t->elem[i].collision != NULL )
				{
					node_t *n = t->elem[i].collision->head;
					while( n != NULL )
					{
						ht_elem_t *e = n->ptr;
						printf( "\t\t%s\n", e->nickname );
						n = n->next;
					}
				}
			}

		}
	}


    queue_t *myq = initialQueue();
    push( myq, "luca" );
    push( myq, "lucia" );
    push( myq, "luciano" );

    node_t *tmp = myq->head;
    while( tmp != NULL )
    {
    	printf( "ORIGINAL: %s\t", tmp->ptr );
    	tmp = tmp->next;
    }

    printf("\n\n\nOUT: %s\n\n", pull( myq ) );

    tmp = myq->head;
    while( tmp != NULL )
	{
		printf( "LAST: %s\t", tmp->ptr );
		tmp = tmp->next;
	}

